<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [链表和数组](#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84)
  - [三种常用的内存淘汰算法](#%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [数组和链表的对比](#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94)
  - [检查链表代码的边界值](#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%B9%E7%95%8C%E5%80%BC)
- [栈](#%E6%A0%88)
  - [栈在表达式求值中的应用](#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
  - [栈在括号匹配中的应用](#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
- [队列](#%E9%98%9F%E5%88%97)
  - [顺序队列](#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97)
  - [循环队列](#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97)
  - [阻塞队列和并发队列](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97)
- [递归](#%E9%80%92%E5%BD%92)
- [排序](#%E6%8E%92%E5%BA%8F)
  - [桶排序](#%E6%A1%B6%E6%8E%92%E5%BA%8F)
  - [计数排序](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
  - [基数排序](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 链表和数组  

#### 三种常用的内存淘汰算法  

- 先进先出策略FIFO（First In，First Out）  

- 最少使用策略LFU（Least Frequently Used）  

- 最近最少使用策略LRU（Least Recently Used）  

#### 数组和链表的对比

数组需要的是一连串的内存空间，链表则不需要   

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。  

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。  

#### 检查链表代码的边界值

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 栈

栈的数据结构，后进者先出，先进者后出，只允许在一端插入和删除数据。  

#### 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    

#### 栈在括号匹配中的应用  

可以借助栈来检查表达式中的括号是否匹配  

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。  

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。  

leetCode中在相关的题目【20,155,232,844,224,682,496】  

### 队列

队列是先进先出，在队尾进行数据入队，在对头进行数据出队。  

队列的实现可以使用数组或者链表  

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。  

#### 顺序队列

队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。  

数组中的删除操作会导致数组中的数据不连续，这时候就需要使用**数据搬移**了。 

当队列的tail指针移动到数组的最右边后，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。  

#### 循环队列

使用顺序队列会发生数据搬移的情况，使用循环队列就可以解决这个问题了。  

当然实现起来难度更大一点，最重要的是**确定好队空和队满的判定条件**。  

队列为空的判断条件仍然是head == tail， 当队满时，(tail+1)%n=head。  

#### 阻塞队列和并发队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。                    
 
 力扣题号：933，225，622，641
 
### 递归

递归需要满足的三个条件  

- 1.一个问题的解可以分解为几个子问题的解  

- 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  
- 3.存在递归终止条件

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**


1、递归代码要警惕堆栈溢出   

2、递归代码要警惕重复计算  

### 排序

#### 桶排序

桶排序的核心主要是要确定桶的大小，已经数据如何落桶  

```go
	bucketCount := make([][]int, (max-min)%10+1)
	for _, item := range arr {
		bucketCount[(item-min)%10] = append(bucketCount[(item-min)%10], item)
	}
```

这里借助于二维数组来实现  

来分析下复杂度  

如果桶内的排序使用的是快排，则每个桶的时间复杂度为O(k * logk)，然后我们可能有m个桶，m个桶排序的时间复杂度就是O(m * k * logk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n*log(n/m))  

当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。  

如果极端情况下，桶所有的数据都落到了一个桶，那么时间负载都是就是O(nlogn)了  

空间复杂度，就是O(N+M)   

#### 计数排序

计数排序和桶排序的实现差不多，可以认为计数排序其实是桶排序的一种特殊情况。   

计数排序中的桶，更精细了，每个桶只存储一个数字，这样每个桶中就不用排序了    

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  

#### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。  

栗子：  

比如将10万个电话号码进行排序，这时候使用基数排序就比较合适了。   

假设要比较两个手机号码a，b的大小，如果在前面几位中，a手机号码已经比b手机号码大了，那后面的几位就不用看了。   

关于排序算法中的总结：  

在排序数量很小的情况下，O(nlogn)也并不是最快的；  

对于排序中的分区点的选取，可以使用 1.三数取中法，2、随机法 等一系列方法 

#### 二分查找

二分查找也是有局限性的  

1、二分查找依赖的是顺序表结构，简单点说就是数组。  

2、二分查找针对的是有序数据。  

3、数据量太小不适合二分查找。  

直接遍历就可以了   

4、数据量太大也不适合二分查找  


  
  





  





 
   





