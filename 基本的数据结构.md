<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [链表和数组](#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84)
  - [三种常用的内存淘汰算法](#%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [数组和链表的对比](#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94)
  - [检查链表代码的边界值](#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%B9%E7%95%8C%E5%80%BC)
- [栈](#%E6%A0%88)
  - [栈在表达式求值中的应用](#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
  - [栈在括号匹配中的应用](#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
- [队列](#%E9%98%9F%E5%88%97)
  - [顺序队列](#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97)
  - [循环队列](#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97)
  - [阻塞队列和并发队列](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97)
- [递归](#%E9%80%92%E5%BD%92)
- [排序](#%E6%8E%92%E5%BA%8F)
  - [桶排序](#%E6%A1%B6%E6%8E%92%E5%BA%8F)
  - [计数排序](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
  - [基数排序](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)
- [二分查找](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
- [跳表](#%E8%B7%B3%E8%A1%A8)
  - [数据的插入](#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5)
  - [跳表索引动态更新](#%E8%B7%B3%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0)
  - [为什么redis使用跳表不使用红黑树](#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91)
- [散列表](#%E6%95%A3%E5%88%97%E8%A1%A8)
  - [散列冲突](#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81)
  - [构建一个合理的散列](#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%88%E7%90%86%E7%9A%84%E6%95%A3%E5%88%97)
  - [LRU缓存淘汰算法](#lru%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [为什么散列表和链表经常一块使用](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E5%9D%97%E4%BD%BF%E7%94%A8)
- [哈希算法](#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)
  - [什么是哈希算法](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)
  - [安全加密](#%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86)
  - [唯一标识](#%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86)
  - [数据校验](#%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C)
  - [负载均衡](#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)
  - [数据分片](#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87)
  - [分布式存储](#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8)
- [树](#%E6%A0%91)
  - [树](#%E6%A0%91-1)
  - [高度，深度，层](#%E9%AB%98%E5%BA%A6%E6%B7%B1%E5%BA%A6%E5%B1%82)
  - [二叉树（Binary Tree）](#%E4%BA%8C%E5%8F%89%E6%A0%91binary-tree)
  - [二叉树的遍历](#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86)
  - [二叉查找树](#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
  - [支持重复数据的二叉查找树](#%E6%94%AF%E6%8C%81%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
  - [时间复杂度分析](#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90)
  - [二叉树对比散列](#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%B9%E6%AF%94%E6%95%A3%E5%88%97)
- [平衡二叉查找树](#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91)
- [红黑树](#%E7%BA%A2%E9%BB%91%E6%A0%91)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 链表和数组  

#### 三种常用的内存淘汰算法  

- 先进先出策略FIFO（First In，First Out）  

- 最少使用策略LFU（Least Frequently Used）  

- 最近最少使用策略LRU（Least Recently Used）  

#### 数组和链表的对比

数组需要的是一连串的内存空间，链表则不需要   

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。  

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。  

#### 检查链表代码的边界值

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 栈

栈的数据结构，后进者先出，先进者后出，只允许在一端插入和删除数据。  

#### 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    

#### 栈在括号匹配中的应用  

可以借助栈来检查表达式中的括号是否匹配  

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。  

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。  

leetCode中在相关的题目【20,155,232,844,224,682,496】  

### 队列

队列是先进先出，在队尾进行数据入队，在对头进行数据出队。  

队列的实现可以使用数组或者链表  

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。  

#### 顺序队列

队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。  

数组中的删除操作会导致数组中的数据不连续，这时候就需要使用**数据搬移**了。 

当队列的tail指针移动到数组的最右边后，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。  

#### 循环队列

使用顺序队列会发生数据搬移的情况，使用循环队列就可以解决这个问题了。  

当然实现起来难度更大一点，最重要的是**确定好队空和队满的判定条件**。  

队列为空的判断条件仍然是head == tail， 当队满时，(tail+1)%n=head。  

#### 阻塞队列和并发队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。                    
 
 力扣题号：933，225，622，641
 
### 递归

递归需要满足的三个条件  

- 1.一个问题的解可以分解为几个子问题的解  

- 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  
- 3.存在递归终止条件

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**


1、递归代码要警惕堆栈溢出   

2、递归代码要警惕重复计算  

### 排序

#### 桶排序

桶排序的核心主要是要确定桶的大小，已经数据如何落桶  

```go
	bucketCount := make([][]int, (max-min)%10+1)
	for _, item := range arr {
		bucketCount[(item-min)%10] = append(bucketCount[(item-min)%10], item)
	}
```

这里借助于二维数组来实现  

来分析下复杂度  

如果桶内的排序使用的是快排，则每个桶的时间复杂度为O(k * logk)，然后我们可能有m个桶，m个桶排序的时间复杂度就是O(m * k * logk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n*log(n/m))  

当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。  

如果极端情况下，桶所有的数据都落到了一个桶，那么时间负载都是就是O(nlogn)了  

空间复杂度，就是O(N+M)   

#### 计数排序

计数排序和桶排序的实现差不多，可以认为计数排序其实是桶排序的一种特殊情况。   

计数排序中的桶，更精细了，每个桶只存储一个数字，这样每个桶中就不用排序了    

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  

#### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。  

栗子：  

比如将10万个电话号码进行排序，这时候使用基数排序就比较合适了。   

假设要比较两个手机号码a，b的大小，如果在前面几位中，a手机号码已经比b手机号码大了，那后面的几位就不用看了。   

关于排序算法中的总结：  

在排序数量很小的情况下，O(nlogn)也并不是最快的；  

对于排序中的分区点的选取，可以使用 1.三数取中法，2、随机法 等一系列方法 

### 二分查找

**二分查找也是有局限性的**  

1、二分查找依赖的是顺序表结构，简单点说就是数组。  

2、二分查找针对的是有序数据。  

3、数据量太小不适合二分查找。  

直接遍历就可以了   

4、数据量太大也不适合二分查找 

**关于 O(logn) 时间复杂度**  

O(logn)这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级O(1)的算法还要高效。
  
因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧？大约是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。  

我们前面讲过，用大O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是一个非常大的常量值，比如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。  

**需要注意的点**

1、循环退出的条件  

注意是low<=high，而不是low<high。  

2、mid的取值  

low+(high-low)/2  

3、low和high的更新  

low=mid+1，high=mid-1。注意这里的+1和-1，如果直接写成low=mid或者high=mid，就可能会发生死循环。比如，当high=3，low=3时，如果a[3]不等于value，就会导致一直循环不退出。    

### 跳表

其中 redis 中的有序集合就是使用跳表来实现的  

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。  

链表加多级索引的结构，就是跳表  

<img src="/img/skip-table.jpeg" alt="skip-table" />  

跳表中需要额外的内存空间，因为需要存储额外的索引空间，几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2  

#### 数据的插入

对于在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。  

使用跳表就很快了，对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是O(logn)。  

#### 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。  

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。  

#### 为什么redis使用跳表不使用红黑树  

Redis中的核心操作主要是下面几个  

- 插入一个数据；

- 删除一个数据；

- 查找一个数据；

- 按照区间查找数据（比如查找值在[100, 356]之间的数据）；

- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。  

对于按照区间查找数据这个操作，跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。  

redis使用跳表还有就是跳相对红黑树容易理解，并且容易实现  

不过，跳表也不能完全替代红黑树，红黑树出现的比较早，很多地方已经实现了红黑树，如果选跳表就需要自己去实现了。 

### 散列表

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。  

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。  

该如何构造散列函数呢？有三点散列函数设计的基本要求：  

1、散列函数计算得到的散列值是一个非负整数；   

2、如果key1 = key2，那hash(key1) == hash(key2)；  

3、如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。   

不过上面的第三点，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。  

所以就需要处理散列冲突  

#### 散列冲突

关于冲突我们一般有两类处理办法  

1、开放寻址法  

2、链表法  

**开放寻址法的优缺点**

优点：  

散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度  

实现比较简单  

缺点：  

删除数据比较麻烦，需要在删除的时候对删除的数据进行标记  

因为所有的数据，都是存储的数组中，对比链表法，解决冲突的代价更高  

总结：  

当数据量比较小、装载因子小的时候，适合采用开放寻址法   

**链表法优缺点**

优点：  

链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好  

链表法对比开放寻址法，对于装填因子的容忍度比较高，开放寻址法只能适用装载因子小于1的情况。对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。  

链表中需要存储指针，对于比较小的对象的存储，是比较消耗内存的，还有可能导致内存消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这方面对于执行效率也有一定的影响。当然使用大内存的存储对象的时候，效率就相对比较高了。  

总结：  

对于链表法我们可以稍加改造，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是O(logn)。  

总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。  

#### 构建一个合理的散列  

1、设计一个合适的散列函数；  

2、定义装载因子阈值，并且设计动态扩容策略；  

3、选择合适的散列冲突解决方法。  

#### LRU缓存淘汰算法

通过散列表加链表实现一个时间复杂度是O(1)的LRU缓存淘汰算法  

这里会引入两个链表  

一个就是拉链法的链表，另一个就是方便快速删除和插入的双向链表  

<img src="/img/hash_1.jpeg" alt="hash" />  

如何插入，添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。  

如何删除一个数据。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在O(1)时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针O(1)时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要O(1)的时间复杂度。  

所以通过散列表和双向链表的组合使用，实现了一个高效的、支持LRU缓存淘汰算法的缓存系统原型。 

#### 为什么散列表和链表经常一块使用

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。  

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。  

### 哈希算法

#### 什么是哈希算法

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。  

哈希算法的几点要求  

- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
  
- 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；
  
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 

- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

哈希值还是会存在冲突的，不过随着位数的增加，发生冲突的概率就会小很多   

#### 安全加密 

如果我们拿到一个MD5哈希值，希望通过毫无规律的穷举的方法，找到跟这个MD5值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的。  

例如 MD5，有2^128个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于1/2^128。    

#### 唯一标识

来个栗子  

我们需要在海量的图片库中搜索一张图片是否存在？  

很简单通过哈希算法，对每张图片生成一个唯一的值来进行检索  

比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。  

如果需要更快的查找可以放在散列中，这样就能实现时间复杂度为O(1)的查查找了

#### 数据校验

对于一些数据私密的数据避免明文传输，我们可以使用哈希进行加密  

#### 负载均衡

对于负载均衡，使用哈希是一个不错的选择  

我们可以通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。  

#### 数据分片 

**如何统计“搜索关键词”出现的次数？**

我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。  

比如我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。  

#### 分布式存储

一致性哈希，能够避免分布式系统的大量数据迁移  

### 树

#### 树

<img src="/img/tree_1.jpeg" alt="tree" />  

关于树节点中的称呼   

- A 节点是 B 节点的父节点  

- B 节点是 A 节点的子节点  

- B、C、D这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点    

- 没有父节点的节点叫做根节点，图中的 E 节点就是根节点  

- 没有子节点的节点叫做叶子节点或者叶节点，比如图中的G、H、I、J、K、L都是叶子节点  

#### 高度，深度，层  

- 节点的高度：节点到叶子节点的额最长路径（边数）

- 节点的深度：根节点到这个节点所经历的边的个数  

- 节点的层数：节点的深度加一  

- 树的高度：根节点的高度  

<img src="/img/tree_2.jpeg" alt="tree" />  

#### 二叉树（Binary Tree）

二叉树只两个叉，也就是两个节点，分别是左子节点和右子节点。二叉树并不要求每个节点必须有两个子节点，有的节点有左节点，有的节点有右节点。  

**满二叉树**

除了叶子节点外，每个节点都有左右节点的成为满二叉树  

**完全二叉树**

叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大。  

树可以使用链表和数组进行存储  

**链式存储**

每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针  

大部分二叉树代码都是通过这种结构来实现的。  

**顺序存储法**

我们把根节点存储在下标i = 1的位置，那左子节点存储在下标2 * i = 2的位置，右子节点存储在2 * i + 1 = 3的位置。以此类推，B节点的左子节点存储在2 * i = 2 * 2 = 4的位置，右子节点存储在2 * i + 1 = 2 * 2 + 1 = 5的位置。  

<img src="/img/tree_3.jpeg" alt="tree" />   

总结一下就是  

如果节点X存储在数组中下标为i的位置，下标为2 * i 的位置存储的就是左子节点，下标为2 * i + 1的位置存储的就是右子节点。反过来，下标为i/2的位置存储就是它的父节点。   

完全二叉树使用数组最省空间  

#### 二叉树的遍历

关于二叉树的遍历，经典的遍历有三种 前序遍历、中序遍历，后序遍历    

- 前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。

- 中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。

- 后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。

前中后对应的就是打印当前节点顺序，先打印就是前序，这样比较容易记  

<img src="/img/tree_4.jpeg" alt="tree" />     

#### 二叉查找树  

二叉查找树又叫二叉搜索树。  

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。  

<img src="/img/tree_5.jpeg" alt="tree" />    

**二叉查找树的查找操作** 

查找一个值，先取根节点，判断。如果相等直接返回，大于则在右子树中查询，小于则在左子树中查询。  

**二叉查找树的插入**

二叉查找树的插入过程有点类似查找操作。新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。  

类似查找，找到对应的位置插入即可  

**二叉查找树的删除**

这个是相对复杂的  

1、如果要删除的几点没有子节点，只需要直接将父节点中，指向要删除节点的指针置为null，类似下面节点55的删除   

2、如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点13。  

3、最难的就是这个删除的节点有两个节点。我们需要找到这个节点的右子树中的最小节点，把它替换到要删除的节点上。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以应用上面两条规则来删除这个最小节点。比如图中的删除节点18。  

<img src="/img/tree_6.jpeg" alt="tree" />    

#### 支持重复数据的二叉查找树

那如果存储的两个对象键值相同，这种情况该怎么处理呢？我这里有两种解决方法。  

1、二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。类似散列中发生冲冲突了，使用拉拉链法来扩展  

2、每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。  

<img src="/img/tree_7.jpeg" alt="tree" />    

使用第二种的话，我们每次再删除操作的时候，找到对应的值之后还不能停止，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。  

#### 时间复杂度分析

最糟糕的情况，所有的节点都分布在一侧，这时候二叉树就退化成了链表，时间复杂度就是O(n)。  

平衡二叉查找树的高度接近logn，所以插入、删除、查找操作的时间复杂度也比较稳定，是O(logn)。  

#### 二叉树对比散列  

散列的插入，删除，查找时间复杂度是O(1)，非常高效，但是二叉树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是O(logn)，所以为什么要用二叉树呢？  

1、散列表中的数据是无序存储的，如果需要输出有序的数据就需要排序，对于二叉查找树，进行中序遍历，就能在可以在O(n)的时间复杂度内，输出有序的数据序列。   

2、散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在O(logn)。  

3、笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比logn小，所以实际的查找速度可能不一定比O(logn)快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高  

4、散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。  

### 平衡二叉查找树

平衡二叉树的定义：二叉树中任意一个节点的左右子树的高度相差不能大于1。  

平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。  

平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。  

### 红黑树

一颗红黑树满足的要求  

- 根节点是黑色的；  

- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；  

- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；  

- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；  

红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是O(logn)。  



    



































  



















  





 
   





