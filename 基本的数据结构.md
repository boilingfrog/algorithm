<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [链表和数组](#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84)
  - [三种常用的内存淘汰算法](#%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [数组和链表的对比](#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94)
  - [检查链表代码的边界值](#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%B9%E7%95%8C%E5%80%BC)
- [栈](#%E6%A0%88)
  - [栈在表达式求值中的应用](#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
  - [栈在括号匹配中的应用](#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
- [队列](#%E9%98%9F%E5%88%97)
  - [顺序队列](#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97)
  - [循环队列](#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97)
  - [阻塞队列和并发队列](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97)
- [递归](#%E9%80%92%E5%BD%92)
- [排序](#%E6%8E%92%E5%BA%8F)
  - [桶排序](#%E6%A1%B6%E6%8E%92%E5%BA%8F)
  - [计数排序](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
  - [基数排序](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)
- [二分查找](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
- [跳表](#%E8%B7%B3%E8%A1%A8)
  - [数据的插入](#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5)
  - [跳表索引动态更新](#%E8%B7%B3%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0)
  - [为什么redis使用跳表不使用红黑树](#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91)
- [散列表](#%E6%95%A3%E5%88%97%E8%A1%A8)
  - [散列冲突](#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81)
  - [构建一个合理的散列](#%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%90%88%E7%90%86%E7%9A%84%E6%95%A3%E5%88%97)
  - [LRU缓存淘汰算法](#lru%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [为什么散列表和链表经常一块使用](#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%A3%E5%88%97%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%BB%8F%E5%B8%B8%E4%B8%80%E5%9D%97%E4%BD%BF%E7%94%A8)
- [哈希算法](#%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)
  - [什么是哈希算法](#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95)
  - [安全加密](#%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86)
  - [唯一标识](#%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86)
  - [数据校验](#%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C)
  - [负载均衡](#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1)
  - [数据分片](#%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87)
  - [分布式存储](#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 链表和数组  

#### 三种常用的内存淘汰算法  

- 先进先出策略FIFO（First In，First Out）  

- 最少使用策略LFU（Least Frequently Used）  

- 最近最少使用策略LRU（Least Recently Used）  

#### 数组和链表的对比

数组需要的是一连串的内存空间，链表则不需要   

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。  

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。  

#### 检查链表代码的边界值

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 栈

栈的数据结构，后进者先出，先进者后出，只允许在一端插入和删除数据。  

#### 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    

#### 栈在括号匹配中的应用  

可以借助栈来检查表达式中的括号是否匹配  

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。  

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。  

leetCode中在相关的题目【20,155,232,844,224,682,496】  

### 队列

队列是先进先出，在队尾进行数据入队，在对头进行数据出队。  

队列的实现可以使用数组或者链表  

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。  

#### 顺序队列

队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。  

数组中的删除操作会导致数组中的数据不连续，这时候就需要使用**数据搬移**了。 

当队列的tail指针移动到数组的最右边后，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。  

#### 循环队列

使用顺序队列会发生数据搬移的情况，使用循环队列就可以解决这个问题了。  

当然实现起来难度更大一点，最重要的是**确定好队空和队满的判定条件**。  

队列为空的判断条件仍然是head == tail， 当队满时，(tail+1)%n=head。  

#### 阻塞队列和并发队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。                    
 
 力扣题号：933，225，622，641
 
### 递归

递归需要满足的三个条件  

- 1.一个问题的解可以分解为几个子问题的解  

- 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  
- 3.存在递归终止条件

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**


1、递归代码要警惕堆栈溢出   

2、递归代码要警惕重复计算  

### 排序

#### 桶排序

桶排序的核心主要是要确定桶的大小，已经数据如何落桶  

```go
	bucketCount := make([][]int, (max-min)%10+1)
	for _, item := range arr {
		bucketCount[(item-min)%10] = append(bucketCount[(item-min)%10], item)
	}
```

这里借助于二维数组来实现  

来分析下复杂度  

如果桶内的排序使用的是快排，则每个桶的时间复杂度为O(k * logk)，然后我们可能有m个桶，m个桶排序的时间复杂度就是O(m * k * logk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n*log(n/m))  

当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。  

如果极端情况下，桶所有的数据都落到了一个桶，那么时间负载都是就是O(nlogn)了  

空间复杂度，就是O(N+M)   

#### 计数排序

计数排序和桶排序的实现差不多，可以认为计数排序其实是桶排序的一种特殊情况。   

计数排序中的桶，更精细了，每个桶只存储一个数字，这样每个桶中就不用排序了    

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  

#### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。  

栗子：  

比如将10万个电话号码进行排序，这时候使用基数排序就比较合适了。   

假设要比较两个手机号码a，b的大小，如果在前面几位中，a手机号码已经比b手机号码大了，那后面的几位就不用看了。   

关于排序算法中的总结：  

在排序数量很小的情况下，O(nlogn)也并不是最快的；  

对于排序中的分区点的选取，可以使用 1.三数取中法，2、随机法 等一系列方法 

### 二分查找

**二分查找也是有局限性的**  

1、二分查找依赖的是顺序表结构，简单点说就是数组。  

2、二分查找针对的是有序数据。  

3、数据量太小不适合二分查找。  

直接遍历就可以了   

4、数据量太大也不适合二分查找 

**关于 O(logn) 时间复杂度**  

O(logn)这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级O(1)的算法还要高效。
  
因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧？大约是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。  

我们前面讲过，用大O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是一个非常大的常量值，比如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。  

**需要注意的点**

1、循环退出的条件  

注意是low<=high，而不是low<high。  

2、mid的取值  

low+(high-low)/2  

3、low和high的更新  

low=mid+1，high=mid-1。注意这里的+1和-1，如果直接写成low=mid或者high=mid，就可能会发生死循环。比如，当high=3，low=3时，如果a[3]不等于value，就会导致一直循环不退出。    

### 跳表

其中 redis 中的有序集合就是使用跳表来实现的  

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。  

链表加多级索引的结构，就是跳表  

<img src="/img/skip-table.jpeg" alt="skip-table" />  

跳表中需要额外的内存空间，因为需要存储额外的索引空间，几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2  

#### 数据的插入

对于在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。  

使用跳表就很快了，对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是O(logn)。  

#### 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。  

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。  

#### 为什么redis使用跳表不使用红黑树  

Redis中的核心操作主要是下面几个  

- 插入一个数据；

- 删除一个数据；

- 查找一个数据；

- 按照区间查找数据（比如查找值在[100, 356]之间的数据）；

- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。  

对于按照区间查找数据这个操作，跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。  

redis使用跳表还有就是跳相对红黑树容易理解，并且容易实现  

不过，跳表也不能完全替代红黑树，红黑树出现的比较早，很多地方已经实现了红黑树，如果选跳表就需要自己去实现了。 

### 散列表

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。  

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。  

该如何构造散列函数呢？有三点散列函数设计的基本要求：  

1、散列函数计算得到的散列值是一个非负整数；   

2、如果key1 = key2，那hash(key1) == hash(key2)；  

3、如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。   

不过上面的第三点，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。  

所以就需要处理散列冲突  

#### 散列冲突

关于冲突我们一般有两类处理办法  

1、开放寻址法  

2、链表法  

**开放寻址法的优缺点**

优点：  

散列表中的数据都存储在数组中，可以有效地利用CPU缓存加快查询速度  

实现比较简单  

缺点：  

删除数据比较麻烦，需要在删除的时候对删除的数据进行标记  

因为所有的数据，都是存储的数组中，对比链表法，解决冲突的代价更高  

总结：  

当数据量比较小、装载因子小的时候，适合采用开放寻址法   

**链表法优缺点**

优点：  

链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好  

链表法对比开放寻址法，对于装填因子的容忍度比较高，开放寻址法只能适用装载因子小于1的情况。对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。  

链表中需要存储指针，对于比较小的对象的存储，是比较消耗内存的，还有可能导致内存消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对CPU缓存是不友好的，这方面对于执行效率也有一定的影响。当然使用大内存的存储对象的时候，效率就相对比较高了。  

总结：  

对于链表法我们可以稍加改造，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是O(logn)。  

总结一下，基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。  

#### 构建一个合理的散列  

1、设计一个合适的散列函数；  

2、定义装载因子阈值，并且设计动态扩容策略；  

3、选择合适的散列冲突解决方法。  

#### LRU缓存淘汰算法

通过散列表加链表实现一个时间复杂度是O(1)的LRU缓存淘汰算法  

这里会引入两个链表  

一个就是拉链法的链表，另一个就是方便快速删除和插入的双向链表  

<img src="/img/hash_1.jpeg" alt="hash" />  

如何插入，添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。  

如何删除一个数据。我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在O(1)时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针O(1)时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要O(1)的时间复杂度。  

所以通过散列表和双向链表的组合使用，实现了一个高效的、支持LRU缓存淘汰算法的缓存系统原型。 

#### 为什么散列表和链表经常一块使用

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。  

因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。  

### 哈希算法

#### 什么是哈希算法

将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法，而通过原始数据映射之后得到的二进制值串就是哈希值。  

哈希算法的几点要求  

- 从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；
  
- 对输入数据非常敏感，哪怕原始数据只修改了一个Bit，最后得到的哈希值也大不相同；
  
- 散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小； 

- 哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值。

哈希值还是会存在冲突的，不过随着位数的增加，发生冲突的概率就会小很多   

#### 安全加密 

如果我们拿到一个MD5哈希值，希望通过毫无规律的穷举的方法，找到跟这个MD5值相同的另一个数据，那耗费的时间应该是个天文数字。所以，即便哈希算法存在冲突，但是在有限的时间和资源下，哈希算法还是很难被破解的。  

例如 MD5，有2^128个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于1/2^128。    

#### 唯一标识

来个栗子  

我们需要在海量的图片库中搜索一张图片是否存在？  

很简单通过哈希算法，对每张图片生成一个唯一的值来进行检索  

比如，我们可以从图片的二进制码串开头取100个字节，从中间取100个字节，从最后再取100个字节，然后将这300个字节放到一块，通过哈希算法（比如MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。  

如果需要更快的查找可以放在散列中，这样就能实现时间复杂度为O(1)的查查找了

#### 数据校验

对于一些数据私密的数据避免明文传输，我们可以使用哈希进行加密  

#### 负载均衡

对于负载均衡，使用哈希是一个不错的选择  

我们可以通过哈希算法，对客户端IP地址或者会话ID计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。  

#### 数据分片 

**如何统计“搜索关键词”出现的次数？**

我们可以先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度。  

比如我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟n取模，最终得到的值，就是应该被分配到的机器编号。  

#### 分布式存储

一致性哈希，能够避免分布式系统的大量数据迁移  















  



















  





 
   





