### 链表和数组  

#### 三种常用的内存淘汰算法  

- 先进先出策略FIFO（First In，First Out）  

- 最少使用策略LFU（Least Frequently Used）  

- 最近最少使用策略LRU（Least Recently Used）  

#### 数组和链表的对比

数组需要的是一连串的内存空间，链表则不需要   

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。  

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。  

#### 检查链表代码的边界值

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 栈

栈的数据结构，后进者先出，先进者后出，只允许在一端插入和删除数据。  

#### 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    

#### 栈在括号匹配中的应用  

可以借助栈来检查表达式中的括号是否匹配  

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。  

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。  

leetCode中在相关的题目【20,155,232,844,224,682,496】  


