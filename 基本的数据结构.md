<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [链表和数组](#%E9%93%BE%E8%A1%A8%E5%92%8C%E6%95%B0%E7%BB%84)
  - [三种常用的内存淘汰算法](#%E4%B8%89%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95)
  - [数组和链表的对比](#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AF%B9%E6%AF%94)
  - [检查链表代码的边界值](#%E6%A3%80%E6%9F%A5%E9%93%BE%E8%A1%A8%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BE%B9%E7%95%8C%E5%80%BC)
- [栈](#%E6%A0%88)
  - [栈在表达式求值中的应用](#%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
  - [栈在括号匹配中的应用](#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8)
- [队列](#%E9%98%9F%E5%88%97)
  - [顺序队列](#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97)
  - [循环队列](#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97)
  - [阻塞队列和并发队列](#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%92%8C%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97)
- [递归](#%E9%80%92%E5%BD%92)
- [排序](#%E6%8E%92%E5%BA%8F)
  - [桶排序](#%E6%A1%B6%E6%8E%92%E5%BA%8F)
  - [计数排序](#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
  - [基数排序](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)
- [二分查找](#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE)
- [跳表](#%E8%B7%B3%E8%A1%A8)
  - [数据的插入](#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5)
  - [跳表索引动态更新](#%E8%B7%B3%E8%A1%A8%E7%B4%A2%E5%BC%95%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0)
  - [为什么redis使用跳表不使用红黑树](#%E4%B8%BA%E4%BB%80%E4%B9%88redis%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91)
- [散列表](#%E6%95%A3%E5%88%97%E8%A1%A8)
  - [散列冲突](#%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

### 链表和数组  

#### 三种常用的内存淘汰算法  

- 先进先出策略FIFO（First In，First Out）  

- 最少使用策略LFU（Least Frequently Used）  

- 最近最少使用策略LRU（Least Recently Used）  

#### 数组和链表的对比

数组需要的是一连串的内存空间，链表则不需要   

数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法有效预读。  

数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。  

#### 检查链表代码的边界值

- 如果链表为空时，代码是否能正常工作？

- 如果链表只包含一个结点时，代码是否能正常工作？

- 如果链表只包含两个结点时，代码是否能正常工作？

- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

### 栈

栈的数据结构，后进者先出，先进者后出，只允许在一端插入和删除数据。  

#### 栈在表达式求值中的应用

实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。  

如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取2个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。    

#### 栈在括号匹配中的应用  

可以借助栈来检查表达式中的括号是否匹配  

我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。  

当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。  

leetCode中在相关的题目【20,155,232,844,224,682,496】  

### 队列

队列是先进先出，在队尾进行数据入队，在对头进行数据出队。  

队列的实现可以使用数组或者链表  

用数组实现的队列叫作顺序队列，用链表实现的队列叫作链式队列。  

#### 顺序队列

队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。  

数组中的删除操作会导致数组中的数据不连续，这时候就需要使用**数据搬移**了。 

当队列的tail指针移动到数组的最右边后，如果有新的数据入队，我们可以将head到tail之间的数据，整体搬移到数组中0到tail-head的位置。  

#### 循环队列

使用顺序队列会发生数据搬移的情况，使用循环队列就可以解决这个问题了。  

当然实现起来难度更大一点，最重要的是**确定好队空和队满的判定条件**。  

队列为空的判断条件仍然是head == tail， 当队满时，(tail+1)%n=head。  

#### 阻塞队列和并发队列

阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。  

线程安全的队列我们叫作并发队列。最简单直接的实现方式是直接在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。                    
 
 力扣题号：933，225，622，641
 
### 递归

递归需要满足的三个条件  

- 1.一个问题的解可以分解为几个子问题的解  

- 2.这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样
  
- 3.存在递归终止条件

**编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。**


1、递归代码要警惕堆栈溢出   

2、递归代码要警惕重复计算  

### 排序

#### 桶排序

桶排序的核心主要是要确定桶的大小，已经数据如何落桶  

```go
	bucketCount := make([][]int, (max-min)%10+1)
	for _, item := range arr {
		bucketCount[(item-min)%10] = append(bucketCount[(item-min)%10], item)
	}
```

这里借助于二维数组来实现  

来分析下复杂度  

如果桶内的排序使用的是快排，则每个桶的时间复杂度为O(k * logk)，然后我们可能有m个桶，m个桶排序的时间复杂度就是O(m * k * logk)，因为k=n/m，所以整个桶排序的时间复杂度就是O(n*log(n/m))  

当桶的个数m接近数据个数n时，log(n/m)就是一个非常小的常量，这个时候桶排序的时间复杂度接近O(n)。  

如果极端情况下，桶所有的数据都落到了一个桶，那么时间负载都是就是O(nlogn)了  

空间复杂度，就是O(N+M)   

#### 计数排序

计数排序和桶排序的实现差不多，可以认为计数排序其实是桶排序的一种特殊情况。   

计数排序中的桶，更精细了，每个桶只存储一个数字，这样每个桶中就不用排序了    

计数排序只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。  

#### 基数排序

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果a数据的高位比b数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到O(n)了。  

栗子：  

比如将10万个电话号码进行排序，这时候使用基数排序就比较合适了。   

假设要比较两个手机号码a，b的大小，如果在前面几位中，a手机号码已经比b手机号码大了，那后面的几位就不用看了。   

关于排序算法中的总结：  

在排序数量很小的情况下，O(nlogn)也并不是最快的；  

对于排序中的分区点的选取，可以使用 1.三数取中法，2、随机法 等一系列方法 

### 二分查找

**二分查找也是有局限性的**  

1、二分查找依赖的是顺序表结构，简单点说就是数组。  

2、二分查找针对的是有序数据。  

3、数据量太小不适合二分查找。  

直接遍历就可以了   

4、数据量太大也不适合二分查找 

**关于 O(logn) 时间复杂度**  

O(logn)这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级O(1)的算法还要高效。
  
因为logn是一个非常“恐怖”的数量级，即便n非常非常大，对应的logn也很小。比如n等于2的32次方，这个数很大了吧？大约是42亿。也就是说，如果我们在42亿个数据中用二分查找一个数据，最多需要比较32次。  

我们前面讲过，用大O标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1)有可能表示的是一个非常大的常量值，比如O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有O(logn)的算法执行效率高。  

**需要注意的点**

1、循环退出的条件  

注意是low<=high，而不是low<high。  

2、mid的取值  

low+(high-low)/2  

3、low和high的更新  

low=mid+1，high=mid-1。注意这里的+1和-1，如果直接写成low=mid或者high=mid，就可能会发生死循环。比如，当high=3，low=3时，如果a[3]不等于value，就会导致一直循环不退出。    

### 跳表

其中 redis 中的有序集合就是使用跳表来实现的  

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。  

链表加多级索引的结构，就是跳表  

<img src="/img/skip-table.jpeg" alt="skip-table" />  

跳表中需要额外的内存空间，因为需要存储额外的索引空间，几级索引的结点总和就是n/2+n/4+n/8…+8+4+2=n-2  

#### 数据的插入

对于在单链表中，一旦定位好要插入的位置，插入结点的时间复杂度是很低的，就是O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。  

使用跳表就很快了，对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是O(logn)。  

#### 跳表索引动态更新

当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。  

我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。  

#### 为什么redis使用跳表不使用红黑树  

Redis中的核心操作主要是下面几个  

- 插入一个数据；

- 删除一个数据；

- 查找一个数据；

- 按照区间查找数据（比如查找值在[100, 356]之间的数据）；

- 迭代输出有序序列。

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。  

对于按照区间查找数据这个操作，跳表可以做到O(logn)的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。  

redis使用跳表还有就是跳相对红黑树容易理解，并且容易实现  

不过，跳表也不能完全替代红黑树，红黑树出现的比较早，很多地方已经实现了红黑树，如果选跳表就需要自己去实现了。 

### 散列表

散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。  

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是O(1)的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。  

该如何构造散列函数呢？有三点散列函数设计的基本要求：  

1、散列函数计算得到的散列值是一个非负整数；   

2、如果key1 = key2，那hash(key1) == hash(key2)；  

3、如果key1 ≠ key2，那hash(key1) ≠ hash(key2)。   

不过上面的第三点，要想找到一个不同的key对应的散列值都不一样的散列函数，几乎是不可能的。  

所以就需要处理散列冲突  

#### 散列冲突

关于冲突我们一般有两类处理办法  

1、开放寻址法  

2、链表法  















  





 
   





