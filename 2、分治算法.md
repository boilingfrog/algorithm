<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [分治算法](#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95)
  - [分治算法的思想](#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E6%83%B3)
    - [分治算法和递归的区别](#%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E5%92%8C%E9%80%92%E5%BD%92%E7%9A%84%E5%8C%BA%E5%88%AB)
    - [使用分治算法需要满足的条件](#%E4%BD%BF%E7%94%A8%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95%E9%9C%80%E8%A6%81%E6%BB%A1%E8%B6%B3%E7%9A%84%E6%9D%A1%E4%BB%B6)
  - [经典题目](#%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE)
    - [剑指 Offer 51. 数组中的逆序对](#%E5%89%91%E6%8C%87-offer-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 分治算法

### 分治算法的思想

分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。   

#### 分治算法和递归的区别  

分治是处理问题的思想，递归是一种编程技巧。分治一般都比较适合用用递归来实现。   

分治算法的实现中，每一层地递归都会涉及到下面三个操作：  

分解：将原问题分解成一系列子问题；  

解决：将子问题的结果合并成原问题。   

#### 使用分治算法需要满足的条件  

1、原问题与分解成的小问题具有相同的模式；  

2、原问题分解成的子问题可以独立求解，子问题之间没有相关性；  

3、具有分解终止条件，也就是说，当问题足够小时，可以直接求解；  

4、可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。  

### 经典题目  

#### 1、二分搜索

给定一个n个元素有序的（升序）整型数组nums 和一个目标值target ，写一个函数搜索nums中的 target，如果目标值存在返回下标，否则返回 -1。  

示例 1:

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4 
```

示例2:

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

链接：https://leetcode.cn/problems/binary-search


#### 剑指 Offer 51. 数组中的逆序对

题目地址：`https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/`

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。  

```
输入: [7,5,6,4]
输出: 5
```

解题思路  

首先用到的是分治算法的思想  

1、什么是逆序对，就是前面的数字大小，小于位于其后面的数字大小，那么这就是一个逆序对；  

2、利用


```go
func reversePairs(nums []int) int {
    return mergeSort(nums, 0, len(nums)-1)
}

func mergeSort(nums []int, start, end int) int {
    if start >= end {
        return 0
    }
    mid := start + (end - start)/2
    cnt := mergeSort(nums, start, mid) + mergeSort(nums, mid + 1, end)
    tmp := []int{}
    i, j := start, mid + 1
    for i <= mid && j <= end {
        if nums[i] <= nums[j] {
            tmp = append(tmp, nums[i])
            cnt += j - (mid + 1)
            i++
        } else {
            tmp = append(tmp, nums[j])
            j++
        }
    }
    for ; i <= mid; i++ {
        tmp = append(tmp, nums[i])
        cnt += end - (mid + 1) + 1
    }
    for ; j <= end; j++ {
        tmp = append(tmp, nums[j])
    }
    for i := start; i <= end; i++ {
        nums[i] = tmp[i - start]
    }
    return cnt
}
```


### 参考

【数据结构与算法之美】https://time.geekbang.org/column/intro/100017301    
【经典优化算法之分治法】https://zhuanlan.zhihu.com/p/45986027    
