<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [复杂度](#%E5%A4%8D%E6%9D%82%E5%BA%A6)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [时间复杂度](#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
  - [空间复杂度](#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 复杂度

### 前言

来复习下，算法体重经常聊到的复杂度  

算法中我们经常会从两个角度去考虑算法的优劣，那就是【时间维度】和【空间维度】   

### 时间复杂度

时间复杂度：就是执行当前算法消耗的时间。  

当然我们这里讲的时间复杂度是个更加通用的描述，因为我们知道代码在不同中机器中执行的时间是不同的，性能好的机器可能就用的时间更短。

所以我们这里的时间复杂度，用的是【大O符号表示法】，即`T(n) = O(f(n))`     

如何理解呢？先来个栗子   

```go
func sum(n int)  int {
	sum :=0
	i:=3
	for m:=0;m<n;m++ {
		sum+=n*i+1
	}
	return sum
}
```  

比如上面这段代码，循环了n次，那么时间复杂度就是O(n)，如何分析呢？  

我们假定每行代码执行的时间是一个时间颗粒，那我们上面的例子，第2和3行一共两个时间颗粒，4和5行就是2*n个时间颗粒，总共就是(2n+2)个时间颗粒。  

当着这样算下来时间复杂度是`T(n) = O(2n+2)`，大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。  

如果 n 很大时，而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。也就是2n中的2和常量2都可以忽略，所以时间复杂度就是`T(n) = O(n)`   

### 空间复杂度




### 参考

【算法的时间与空间复杂度（一看就懂）】https://zhuanlan.zhihu.com/p/50479555  