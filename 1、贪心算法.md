<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [贪心算法](#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [什么是贪心算法](#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)
  - [下面来几个实战的栗子](#%E4%B8%8B%E9%9D%A2%E6%9D%A5%E5%87%A0%E4%B8%AA%E5%AE%9E%E6%88%98%E7%9A%84%E6%A0%97%E5%AD%90)
    - [55.跳跃游戏](#55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F)
    - [45.跳跃游戏 II](#45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii)
    - [455.分发饼干](#455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 贪心算法

### 前言

贪心算法作为几个比较基础的算法思想之一，有必要花点时间去研究下  

### 什么是贪心算法

贪心算法，又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法需要充分挖掘题目中条件，没有固定的模式，解决有贪心算法需要一定的直觉和经验。  

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。  

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。  

**贪心算法的基本步骤：**    

1、从某个初始解出发；  

2、采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；  

3、将所有解综合起来。

**贪心算法的缺点：**   

优点：简单，高效，省去了为了找最优解可能需要穷举操作，通常作为其它算法的辅助算法来使用；   

缺点：不从总体上考虑其它可能情况，每次选取局部最优解，不再进行回溯处理，所以很少情况下得到最优解。   

### 下面来几个实战的栗子

#### 55.跳跃游戏

题目链接：https://leetcode-cn.com/problems/jump-game

给定一个非负整数数组nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例1：

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

示例2： 

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

**解题思路**  

思路1  

能够到达最后一个节点，我们对其进行拆分，拆成一个个的子问题  

就意味着，上一个节点能跳动的最大范围，能够到达当前的节点，如果不能就肯定不能跳转到到最后一个节点了   

时间复杂度 `O(N)`  

空间复杂度 `O(1)`  

```go
func canJump(nums []int) bool {
	target, num := 0, len(nums)
	for i := 0; i < num-1; i++ {
		if i > target {
			return false
		}

		if nums[i]+i > target {
			target = nums[i] + i
		}
	}

	if target >= num-1 {
		return true
	}

	return false
}
```

思路2  

能跳转到最后，可以理解为从最后面一个节点往前遍历，总有一个节点能够跳转到当前的节点     

从后面开始遍历，如果前一个节点的跳转长度能到当前节点，当前节点前移，依次循环，之后遍历完所有的节点

最后只要判断当前节点的下标，如果标已经移动到了最前面，返回true  

时间复杂度 `O(N)`  

空间复杂度 `O(1)`    

```
func canJump(nums []int) bool {
	target, num := len(nums)-1, len(nums)-1
	for i := num - 1; i >= 0; i-- {
		if i+nums[i] >= target {
			target = i
		}
	}

	if target <= 0 {
		return true
	}

	return false
}
```

用的是贪心的思想，每次只考虑一个分支的最优，一个个迭代   

#### 45.跳跃游戏 II

题目链接：https://leetcode-cn.com/problems/jump-game

给你一个非负整数数组nums ，你最初位于数组的第一个位置。  

数组中的每个元素代表你在该位置可以跳跃的最大长度。  

你的目标是使用最少的跳跃次数到达数组的最后一个位置。  

假设你总是可以到达数组的最后一个位置。  

示例 1:

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
    从下标为 0 跳到下标为 1 的位置，跳1步，然后跳3步到达数组的最后一个位置。
```

示例 2:  

```
输入: nums = [2,3,0,1,4]
输出: 2
```

思路1   

这道题目的难点是，选择合适的时机增加跳转的步骤   

每次在上次能跳到的范围（end）内选择一个能跳的最远的位置

时间复杂度 `O(N)`  

空间复杂度 `O(1)`   

```go
func jump(nums []int) int {
	steps := 0
	end := 0
	maxTarget := 0

	for i := 0; i < len(nums)-1; i++ {
		if i+nums[i] > maxTarget {
			maxTarget = i + nums[i]
		}

		// 这一步是精华
		// 到了上一步跳转能到的最大范围值的时候，增加跳转的步骤
		if end == i {
			// 下次可跳转的最大位置
			end = maxTarget
			steps++
		}
	}

	return steps
}
```

思路2  

从最后的一个节点开始循环，然后找到能跳转到当前节点的最小索引的节点，然后更新当前节点到刚刚找到的最小节点，依次循环。。。。。

时间复杂度 `O(N^2)`  

空间复杂度 `O(1)`   

```go
func jump(nums []int) int {
	steps := 0
	position := len(nums) - 1

	for position > 0 {
		// 里面的循环从头开始循环，这样就能找到能跳转的最小的索引值
		for i := 0; i < position; i++ {
			if nums[i]+i >= position {
				position = i
				steps++
				break
			}
		}
	}

	return steps
}
```

#### 455.分发饼干

题目链接：https://leetcode-cn.com/problems/assign-cookies  

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值`g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸`s[j]`。如果 `s[j]>= g[i]`，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例1:

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

示例2:

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

思路

这个相对比较简单，先满足胃口最小的学生，要对胃口和饼干进行排序  

时间复杂度是：`O(m log m+ n log n)`

空间复杂度：`O(log m + log n)`

```go
func findContentChildren(g []int, s []int) int {
	num := 0
	m := 0
	sort.Ints(g)
	sort.Ints(s)
	for i := 0; i < len(g); i++ {
		for m < len(s) {
			if g[i] <= s[m] {
				num++
				m++
				break
			}
			m++
		}
	}
	return num
}
```

### 参考

【数据结构与算法之美】https://time.geekbang.org/column/intro/100017301    
【贪心算法经典题目】https://www.cnblogs.com/Allen-rg/p/13706673.html    