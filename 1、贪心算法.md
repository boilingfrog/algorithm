<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [贪心算法](#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)
  - [前言](#%E5%89%8D%E8%A8%80)
  - [什么是贪心算法](#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95)
  - [下面来几个实战的栗子](#%E4%B8%8B%E9%9D%A2%E6%9D%A5%E5%87%A0%E4%B8%AA%E5%AE%9E%E6%88%98%E7%9A%84%E6%A0%97%E5%AD%90)
    - [55.跳跃游戏](#55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F)
  - [参考](#%E5%8F%82%E8%80%83)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 贪心算法

### 前言

贪心算法作为几个比较基础的算法思想之一，有必要花点时间去研究下  

### 什么是贪心算法

贪心算法，又称贪婪算法，是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法需要充分挖掘题目中条件，没有固定的模式，解决有贪心算法需要一定的直觉和经验。  

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。  

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。  

**贪心算法的基本步骤：**    

1、从某个初始解出发；  

2、采用迭代的过程，当可以向目标前进一步时，就根据局部最优策略，得到一部分解，缩小问题规模；  

3、将所有解综合起来。

**贪心算法的缺点：**   

优点：简单，高效，省去了为了找最优解可能需要穷举操作，通常作为其它算法的辅助算法来使用；   

缺点：不从总体上考虑其它可能情况，每次选取局部最优解，不再进行回溯处理，所以很少情况下得到最优解。   

### 下面来几个实战的栗子

#### 55.跳跃游戏

给定一个非负整数数组nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例1：

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

示例2： 

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

题目链接：https://leetcode-cn.com/problems/jump-game

**解题思路**  

思路1  

能够到达最后一个节点，我们对其进行拆分，拆成一个个的子问题  

就意味着，上一个节点能跳动的最大范围，能够到达当前的节点，如果不能就肯定不能跳转到到最后一个节点了   

```go
func canJump(nums []int) bool {
	target, num := 0, len(nums)
	for i := 0; i < num-1; i++ {
		if i > target {
			return false
		}

		if nums[i]+i > target {
			target = nums[i] + i
		}
	}

	if target >= num-1 {
		return true
	}

	return false
}
```

思路2  

能跳转到最后，可以理解为从最后面一个节点往前遍历，总能找到  

从后面开始遍历，如果前一个节点的跳转长度能到当前节点，当前节点前移，依次循环，之后遍历完所有的节点

最后只要判断当前节点的下标，如果标已经移动到了最前面，返回true  

```
func canJump(nums []int) bool {
	target, num := len(nums)-1, len(nums)-1
	for i := num - 1; i >= 0; i-- {
		if i+nums[i] >= target {
			target = i
		}
	}

	if target <= 0 {
		return true
	}

	return false
}
```

用的是贪心的思想，每次只考虑一个分支的最优，一个个迭代   



### 参考

【数据结构与算法之美】https://time.geekbang.org/column/intro/100017301    
【贪心算法经典题目】https://www.cnblogs.com/Allen-rg/p/13706673.html    